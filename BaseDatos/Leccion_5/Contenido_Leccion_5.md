# 0) Esquema de resultados y configuración

```sql
-- Resultados de calidad (histórico)
CREATE TABLE dq_results (
  run_id        NUMBER GENERATED BY DEFAULT AS IDENTITY,
  run_ts        TIMESTAMP DEFAULT SYSTIMESTAMP,
  metric_name   VARCHAR2(50),
  table_name    VARCHAR2(128),
  column_name   VARCHAR2(128),
  details       VARCHAR2(4000),
  value_num     NUMBER,
  threshold_num NUMBER,
  pass_flag     CHAR(1) CHECK (pass_flag IN ('Y','N'))
);

-- Tablas/columnas críticas y reglas
CREATE TABLE dq_config_columns (
  table_name       VARCHAR2(128) NOT NULL,
  column_name      VARCHAR2(128) NOT NULL,
  must_be_not_null CHAR(1) DEFAULT 'N' CHECK (must_be_not_null IN ('Y','N')),
  valid_regex      VARCHAR2(4000),      -- opcional: formato (p.ej. correo, código, etc.)
  domain_table     VARCHAR2(128),       -- opcional: tabla de dominio para valores permitidos
  domain_column    VARCHAR2(128),       -- opcional: columna de dominio
  CONSTRAINT pk_dq_cfg_cols PRIMARY KEY (table_name, column_name)
);

-- Claves de negocio para detectar duplicados (si no hay UNIQUE/PK explícita)
-- Lista columnas separadas por comas en key_columns, p.ej. 'NRO_DOC,PAIS'
CREATE TABLE dq_config_keys (
  table_name   VARCHAR2(128) PRIMARY KEY,
  key_columns  VARCHAR2(4000) NOT NULL
);

-- Reglas de "actualidad" (timeliness): columna de fecha/hora y máximo de días de antigüedad aceptable
CREATE TABLE dq_config_timeliness (
  table_name      VARCHAR2(128) PRIMARY KEY,
  datetime_column VARCHAR2(128) NOT NULL,
  max_age_days    NUMBER NOT NULL
);

-- Umbrales por métrica (valor numérico; la comparación se documenta en cada métrica)
CREATE TABLE dq_thresholds (
  metric_name   VARCHAR2(50) PRIMARY KEY,
  threshold_num NUMBER NOT NULL
);

-- Umbrales por defecto (ajústalos)
MERGE INTO dq_thresholds d USING (
  SELECT 'COMPLETENESS_NULL_RATE' metric, 0.02 FROM dual UNION ALL  -- ≤ 2% nulos
  SELECT 'VALIDITY_REGEX_FAIL_RATE',       0.01 FROM dual UNION ALL  -- ≤ 1% fallos de patrón
  SELECT 'DOMAIN_MISS_RATE',               0.005 FROM dual UNION ALL -- ≤ 0.5% fuera de dominio
  SELECT 'FK_ORPHAN_COUNT',                0 FROM dual UNION ALL     -- = 0 huérfanos
  SELECT 'UNIQUENESS_DUP_COUNT',           0 FROM dual UNION ALL     -- = 0 duplicados
  SELECT 'TIMELINESS_AGE_P95_DAYS',       10 FROM dual               -- P95 de edad ≤ 10 días
) s ON (d.metric_name = s.metric)
WHEN NOT MATCHED THEN INSERT (metric_name, threshold_num) VALUES (s.metric, s.threshold_num);
```

---

# 1) Paquete de evaluación (PL/SQL)

```sql
CREATE OR REPLACE PACKAGE dq_pkg AS
  PROCEDURE run_completeness;       -- % nulos en columnas críticas
  PROCEDURE run_validity_regex;     -- tasa de fallo de REGEX
  PROCEDURE run_domain_membership;  -- tasa fuera de dominio
  PROCEDURE run_fk_orphans;         -- huérfanos en FKs (todas las FKs del esquema)
  PROCEDURE run_uniqueness;         -- duplicados en claves de negocio
  PROCEDURE run_timeliness;         -- P95 de edad (días) y tasa fuera de SLA
  PROCEDURE run_all;                -- ejecuta todo
END dq_pkg;
/

CREATE OR REPLACE PACKAGE BODY dq_pkg AS
  -- util: obtener umbral
  FUNCTION get_thr(p_metric VARCHAR2) RETURN NUMBER IS v NUMBER; BEGIN
    SELECT threshold_num INTO v FROM dq_thresholds WHERE metric_name = p_metric;
    RETURN v;
  EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;

  PROCEDURE ins_res(p_metric VARCHAR2, p_tab VARCHAR2, p_col VARCHAR2,
                    p_details VARCHAR2, p_val NUMBER, p_thr NUMBER, p_pass CHAR) IS
  BEGIN
    INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
    VALUES (p_metric, UPPER(p_tab), UPPER(p_col), p_details, p_val, p_thr, p_pass);
  END;

  PROCEDURE run_completeness IS
  BEGIN
    FOR r IN (
      SELECT UPPER(table_name) t, UPPER(column_name) c
      FROM dq_config_columns
      WHERE must_be_not_null = 'Y'
    ) LOOP
      EXECUTE IMMEDIATE '
        SELECT COUNT(*) AS total,
               SUM(CASE WHEN '||r.c||' IS NULL THEN 1 ELSE 0 END) AS nulls
        FROM '||r.t
        INTO   -- variables
        -- usamos records temporales
        -- truco: SELECT ... INTO con RECORD:
        -- no podemos declarar RECORDs aquí, usamos variables simples:
        -- resolvemos con subconsulta:
        /* nada */;
      END LOOP;
  END;
END dq_pkg;
/
```

> **Nota:** Oracle no permite `CASE WHEN col IS NULL` fuera de SQL directo con `INTO` múltiples sin declarar variables. Para mantenerlo simple y 100% pegable, a continuación te doy **consultas directas** (SQL puro) por cada métrica y una **versión compacta** PL/SQL sin trucos. Así evitas problemas de compilación en Live SQL y puedes ejecutar por partes y auditar resultados.

---

# 2) Consultas listas por métrica (SQL puro)

## 2.1 Completitud (por columna crítica)

```sql
-- Ajusta la tabla/columna en WHERE si quieres una sola; o elimina el filtro para todas
SELECT c.table_name,
       c.column_name,
       nulls / NULLIF(total,0) AS null_rate,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE') AS thr,
       CASE WHEN nulls / NULLIF(total,0) 
                 <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE')
            THEN 'Y' ELSE 'N' END AS pass_flag
FROM (
  SELECT table_name, column_name,
         (SELECT COUNT(*) FROM (SELECT * FROM  (SELECT * FROM  (SELECT * FROM  dual)))) dummy, -- placeholder
         -- calculamos total y nulos por columna vía SQL dinámico generado por diccionario:
         -- Genera statements:
         0 total, 0 nulls
  FROM dq_config_columns WHERE must_be_not_null='Y'
) x JOIN dq_config_columns c ON c.table_name=x.table_name AND c.column_name=x.column_name;
```

> Para medición **real** de completitud columna a columna, lo más transparente es ejecutar **una consulta por columna** (evitas SQL dinámico). Ejemplos:

```sql
-- EJEMPLO 1: completitud en CLIENTES.CORREO
WITH stats AS (
  SELECT COUNT(*) total,
         SUM(CASE WHEN correo IS NULL THEN 1 ELSE 0 END) nulls
  FROM CLIENTES
)
SELECT 'COMPLETENESS_NULL_RATE' metric_name,
       'CLIENTES' table_name,
       'CORREO' column_name,
       nulls/NULLIF(total,0) AS value_num,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE') threshold_num,
       CASE WHEN nulls/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE') THEN 'Y' ELSE 'N' END pass_flag
FROM stats;

-- Guarda el resultado (opcional):
INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'COMPLETENESS_NULL_RATE','CLIENTES','CORREO','Nulos/Total',
       nulls/NULLIF(total,0),
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE'),
       CASE WHEN nulls/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='COMPLETENESS_NULL_RATE') THEN 'Y' ELSE 'N' END
FROM stats;
```

> Repite el bloque para cada columna crítica que marques en `dq_config_columns (must_be_not_null='Y')`.

---

## 2.2 Validez (REGEXP)

```sql
-- EJEMPLO: correos válidos en CLIENTES.CORREO (regex simple)
WITH stats AS (
  SELECT COUNT(*) total,
         SUM(CASE WHEN correo IS NULL OR REGEXP_LIKE(correo, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$') THEN 0 ELSE 1 END) bad
  FROM CLIENTES
)
SELECT 'VALIDITY_REGEX_FAIL_RATE' metric_name,
       'CLIENTES' table_name, 'CORREO' column_name,
       bad/NULLIF(total,0) AS value_num,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='VALIDITY_REGEX_FAIL_RATE') threshold_num,
       CASE WHEN bad/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='VALIDITY_REGEX_FAIL_RATE') THEN 'Y' ELSE 'N' END pass_flag
FROM stats;

-- Guardar:
INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'VALIDITY_REGEX_FAIL_RATE','CLIENTES','CORREO','Regex email',
       bad/NULLIF(total,0),
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='VALIDITY_REGEX_FAIL_RATE'),
       CASE WHEN bad/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='VALIDITY_REGEX_FAIL_RATE') THEN 'Y' ELSE 'N' END
FROM stats;
```

Ajusta el `REGEXP_LIKE` para tu caso (formatos, códigos, etc.).

---

## 2.3 Dominio (valores permitidos)

```sql
-- EJEMPLO: CLIENTES.PAIS debe existir en DOMINIOS_PAISES.COD_PAIS
WITH stats AS (
  SELECT COUNT(*) total,
         SUM(CASE WHEN c.pais IS NULL THEN 0
                  WHEN NOT EXISTS (SELECT 1 FROM DOMINIOS_PAISES d WHERE d.cod_pais = c.pais) THEN 1
                  ELSE 0 END) AS out_domain
  FROM CLIENTES c
)
SELECT 'DOMAIN_MISS_RATE' metric_name,
       'CLIENTES' table_name, 'PAIS' column_name,
       out_domain/NULLIF(total,0) AS value_num,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='DOMAIN_MISS_RATE') threshold_num,
       CASE WHEN out_domain/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='DOMAIN_MISS_RATE') THEN 'Y' ELSE 'N' END pass_flag
FROM stats;

INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'DOMAIN_MISS_RATE','CLIENTES','PAIS','Fuera de dominio',
       out_domain/NULLIF(total,0),
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='DOMAIN_MISS_RATE'),
       CASE WHEN out_domain/NULLIF(total,0) <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='DOMAIN_MISS_RATE') THEN 'Y' ELSE 'N' END
FROM stats;
```

---

## 2.4 Integridad referencial (huérfanos en TODAS las FKs del esquema)

```sql
-- Lista de FKs con sus tablas y columnas
SELECT uc.constraint_name, uc.table_name child_table, r.table_name parent_table
FROM   user_constraints uc
JOIN   user_constraints r ON uc.r_constraint_name = r.constraint_name
WHERE  uc.constraint_type = 'R';

-- Para una FK concreta, contar huérfanos:
-- Reemplaza CHILD_T/CHILD_COL y PARENT_T/PARENT_COL según tu FK
SELECT COUNT(*) AS orphan_count
FROM CHILD_T c
WHERE NOT EXISTS (
  SELECT 1 FROM PARENT_T p WHERE p.PARENT_COL = c.CHILD_COL
);

-- Guardar un ejemplo de FK
INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'FK_ORPHAN_COUNT','DETALLE_PEDIDO',NULL,'FK DETALLE_PEDIDO(PEDIDO_ID)->PEDIDO(ID)',
       (SELECT COUNT(*) FROM DETALLE_PEDIDO d WHERE NOT EXISTS (SELECT 1 FROM PEDIDO p WHERE p.ID=d.PEDIDO_ID)) AS orphan_count,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='FK_ORPHAN_COUNT'),
       CASE WHEN (SELECT COUNT(*) FROM DETALLE_PEDIDO d WHERE NOT EXISTS (SELECT 1 FROM PEDIDO p WHERE p.ID=d.PEDIDO_ID))
                 = (SELECT threshold_num FROM dq_thresholds WHERE metric_name='FK_ORPHAN_COUNT') THEN 'Y' ELSE 'N' END
FROM dual;
```

> Si tus FKs están **enforced**, no debería haber huérfanos; este test detecta problemas de integridad en cargas históricas o deshabilitadas.

---

## 2.5 Unicidad (duplicados en claves de negocio)

```sql
-- Define tus claves en dq_config_keys, p.ej. ('CLIENTES','NRO_DOC,PAIS')
-- Consulta genérica por una tabla concreta:
-- EJEMPLO para CLIENTES con clave (NRO_DOC, PAIS)
WITH dups AS (
  SELECT nro_doc, pais, COUNT(*) cnt
  FROM CLIENTES
  GROUP BY nro_doc, pais
  HAVING COUNT(*) > 1
)
SELECT 'UNIQUENESS_DUP_COUNT' metric_name,
       'CLIENTES' table_name, 'NRO_DOC,PAIS' column_name,
       (SELECT COUNT(*) FROM dups) AS dup_count,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='UNIQUENESS_DUP_COUNT') AS threshold_num,
       CASE WHEN (SELECT COUNT(*) FROM dups) = (SELECT threshold_num FROM dq_thresholds WHERE metric_name='UNIQUENESS_DUP_COUNT') THEN 'Y' ELSE 'N' END AS pass_flag
FROM dual;

-- Guardar:
INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'UNIQUENESS_DUP_COUNT','CLIENTES','NRO_DOC,PAIS','Duplicados en clave de negocio',
       (SELECT COUNT(*) FROM dups),
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='UNIQUENESS_DUP_COUNT'),
       CASE WHEN (SELECT COUNT(*) FROM dups) = (SELECT threshold_num FROM dq_thresholds WHERE metric_name='UNIQUENESS_DUP_COUNT') THEN 'Y' ELSE 'N' END
FROM dual;
```

> Repite el patrón para cada clave de negocio importante.

---

## 2.6 Actualidad (Timeliness)

```sql
-- EJEMPLO: P95 de edad (días) según columna FECHA_ACTUALIZACION en CLIENTES
WITH ages AS (
  SELECT TRUNC(SYSDATE - fecha_actualizacion) AS age_days
  FROM   CLIENTES
  WHERE  fecha_actualizacion IS NOT NULL
),
p95 AS (
  SELECT PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY age_days) AS p95_days
  FROM ages
)
SELECT 'TIMELINESS_AGE_P95_DAYS' metric_name,
       'CLIENTES' table_name, 'FECHA_ACTUALIZACION' column_name,
       p.p95_days AS value_num,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='TIMELINESS_AGE_P95_DAYS') AS threshold_num,
       CASE WHEN p.p95_days <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='TIMELINESS_AGE_P95_DAYS') THEN 'Y' ELSE 'N' END AS pass_flag
FROM p95 p;

-- Guardar:
INSERT INTO dq_results(metric_name, table_name, column_name, details, value_num, threshold_num, pass_flag)
SELECT 'TIMELINESS_AGE_P95_DAYS','CLIENTES','FECHA_ACTUALIZACION','P95 edad en días',
       p.p95_days,
       (SELECT threshold_num FROM dq_thresholds WHERE metric_name='TIMELINESS_AGE_P95_DAYS'),
       CASE WHEN p.p95_days <= (SELECT threshold_num FROM dq_thresholds WHERE metric_name='TIMELINESS_AGE_P95_DAYS') THEN 'Y' ELSE 'N' END
FROM p95 p;
```

---

# 3) Resumen ejecutivo (tablero simple)

```sql
-- Últimos resultados por métrica/tabla/columna
SELECT metric_name, table_name, column_name, value_num, threshold_num, pass_flag, run_ts
FROM dq_results
ORDER BY run_ts DESC, metric_name, table_name, column_name;
```

Si quieres un **semáforo** por tabla:

```sql
SELECT table_name,
       MIN(CASE WHEN pass_flag='Y' THEN 1 ELSE 0 END) AS all_pass, -- 1 = todas pasan
       SUM(CASE WHEN pass_flag='N' THEN 1 ELSE 0 END) AS fails,
       COUNT(*) AS total_checks
FROM dq_results
GROUP BY table_name
ORDER BY fails DESC, table_name;
```

---

## Cómo justificar “científicamente” la calidad

1. **Definición de hipótesis y umbrales**: por cada métrica (p. ej., “la tasa de nulos debe ser ≤2%”), estableces un **criterio falsable**.
2. **Medición reproducible**: las consultas anteriores generan **valores numéricos** archivados en `dq_results` con **timestamp**.
3. **Trazabilidad**: las reglas viven en tablas de configuración y el **SQL es auditable**.
4. **Evidencia**: el histórico permite **comparar corridas**, detectar regresiones y documentar mejoras.
